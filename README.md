# Задача 1. Розширення функціоналу префіксного дерева

Реалізуйте два додаткових методи для класу Trie:

    count_words_with_suffix(pattern) для підрахунку кількості слів, що закінчуються заданим шаблоном;
    has_prefix(prefix) для перевірки наявності слів із заданим префіксом.

Технічні умови

    Клас Homework має успадковувати базовий клас Trie.
    Методи повинні опрацьовувати помилки введення некоректних даних.
    Вхідні параметри обох методів мають бути рядками.
    Метод count_words_with_suffix має повертати ціле число.
    Метод has_prefix має повертати булеве значення.

1. Метод count_words_with_suffix повертає кількість слів, що закінчуються на заданий pattern. За відсутності слів повертає 0. Враховує регістр символів (10 б).
2. Метод has_prefix повертає True, якщо існує хоча б одне слово із заданим префіксом. Повертає False, якщо таких слів немає. Враховує регістр символів (10 б).
3. Код проходить усі тести (10 б).
4. Обробляються некоректні вхідні дані (10 б).
5. Методи працюють ефективно на великих наборах даних (10 б).

# Задача 2. Пошук найдовшого спільного префікса

Створіть клас LongestCommonWord, який наслідує клас Trie, та реалізуйте метод find_longest_common_word, який знаходить найдовший спільний префікс для всіх слів у вхідному масиві рядків strings.

Технічні умови

    Клас LongestCommonWord має успадковувати Trie.
    Вхідний параметр методу find_longest_common_word, strings — масив рядків.
    Метод find_longest_common_word має повертати рядок — найдовший спільний префікс.
    Час виконання — O(S)O(S), де SS — сумарна довжина всіх рядків.

Критерії прийняття

1. Метод find_longest_common_word:

    повертає найдовший префікс, спільний для всіх слів (10 б),
    повертає пустий рядок, якщо спільного префікса немає (10 б),
    коректно обробляє порожній масив або некоректні вхідні дані (10 б).

2. Код проходить усі тести (20 б).
